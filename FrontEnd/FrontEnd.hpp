/* This header offers some basic tools for creating a Front End */
#ifndef __FRONT_END_H__
#define __FRONT_END_H__

#include "common.hpp"
/* Lex */
#include "LexicalAnalyzer.hpp"
/* Parse */
#include "LR.hpp"
/* ErrorReport */
#include "ErrorReport.hpp"


/* This is used for representing productions in a human readable way */
struct HumanProduction {
    string lhs;
    vector<string> rhs;
};

/* This is used for representing grammers in a human readable way */
struct HumanGrammer {
    vector<HumanProduction> P;
    set<string> I, T, cE;
    /* create a grammer for LR(k) parser */
    HumanGrammer();
    HumanGrammer(int k, string start);
    /* Add a series of productions from a string (syntax in books)*/
    /* e.i. "A -> AB | B | e" (here the 'e' means empty string) */
    void AddProduction(string s);
    void BuildcE();
    void BuildIT();
};



/* use this to store a single MCode sentence */
typedef vector<string> MCodeTuple;

/* use this class to generate mid level code */
struct MCodeBase {
    int begin, end; // [, )
    vector<MCodeBase*> child;
    list<MCodeTuple> code;
    map<string, void*> info; // aux information;
    MCodeBase() { code.clear(); child.clear(); begin = end = -1; info.clear(); }
    virtual ~MCodeBase() {}
    void include(MCodeBase *other) { for (auto item: other -> code) code.push_back(item); }
    void include(MCodeTuple ln) { code.push_back(ln); }
    string ch(int i, int j = 0) { return (child[i] -> code).back()[j]; } // child code
    void* au(int i, string label) { return (child[i] -> info)[label]; } // aux info
    virtual void generate(MCodeBase* ret) { }
    void output(FILE *out) {
        for (auto &tp: code) {
            for (auto s: tp) fprintf(out, "%s ", s.c_str());
            fputs("\n", out);
        }
    }
    string toString() {
        string ret = "";
        for (auto &tp: code) {
            for (auto s: tp) ret += s + " ";
            ret += "\n";
        }
        return ret;
    }
};

// A End to End translator
class FrontEnd {
protected:
    string context;
    map<string, int> s2i;
    map<int, string> i2s;
    HumanGrammer hg;
    LR::Grammer g;
    LR::String sentence;
    LR::ParseTree* tree;
    vector<string> logContent;
    vector<LexicalAnalyzer::LexicalItemInfo> lexResult;
    vector<MCodeBase*> semantic;
    LexicalAnalyzer *lex;
    int k;

    FrontEnd(string context);
    ~FrontEnd();
    
    /* AUX Functions (you should not touch these functions) */
    /* aux function used to construct logContent, we use this function if we want to output the parse tree */
    string handleSpecialCharacter(string s);
    /* aux function to transform a human readable grammer to a grammer that is used by LR algorithm */
    void indexSymbols(HumanGrammer hg, map<string, int> &s2i, map<int, string> &i2s);
    /* Convert a HumanGrammer hg to a Grammer which is recognized by the parser */
    LR::Grammer HG2G(HumanGrammer hg, map<string, int> &s2i, map<int, string> &i2s);
    /* delete the parse tree */
    void deleteTree(LR::ParseTree *rt);

    // the function that the user need to implement
    /* define your lex rules here */
    virtual void lexDefinition() = 0;
    /* handle your lex errors here */
    virtual void lexErrorHandler(LexicalAnalyzer::LexicalErrorInfo errInfo) = 0;
    /* define your grammer and their semantic operations here */
    virtual void grammerDefinition() = 0;
    
    /* states for translation */
    // Lex State
    void LexDefinition();
    void LexProcess();
    virtual bool AfterLex() {return true;}
    // Grammer Stage
    void GrammerDefinition();
    void GrammerProcess();
    virtual bool AfterGrammer() {return true;}
    // Semantic Stage
    MCodeBase* SemanticAnalysis(LR::ParseTree *rt, int &cnt);
    
public:
    // End to End translation
    // @param int k, to perform LR(k) when parsing
    // @param string start, the start symbol of the grammer
    // @ret MCodeBase*, a pointer that represent the mid level code
    // @note: FrontEnd class will not free this pointer.
    MCodeBase* EndToEnd(int k, string start);
    
    // loggers
    // log the lexier's dfa
    void LogDFA();
    // log the parse tree generated by LR
    void LogParseTree();
};

/* AUX Functions which makes it easy to define the grammer with its meaning */
 
/* use this to do P and E */
#define PE(s, ...) do {\
    P(s);\
    E(__VA_ARGS__);\
} while(0)

/* use this to define a production */
#define P(s) hg.AddProduction(s)

/* use this to bind a semantic action to a production */
#define E(...) do {\
    struct MCodeBaseSub : public MCodeBase {\
        virtual void generate(MCodeBase *ret) {\
            __VA_ARGS__\
        }\
    };\
    semantic.push_back(new MCodeBaseSub());\
} while(0)

#endif
